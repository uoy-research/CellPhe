---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# CellPhe

<!-- badges: start -->
<!-- badges: end -->

CellPhe provides functions to accompany the paper (TODO Add reference when available) to phenotype cells from time-lapse videos.

## Installation

You can install the latest version of CellPhe from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("uoy-research/CellPhe")
```

## Example

Included with the package is an example dataset to demonstrate CellPhe's capabilities, this data is available in `data` and comprises 3 parts:

  - The time-lapse stills as TIFF images (`data/05062019_B3_3_imagedata`)
  - Existing pre-extracted features (`data/05062019_B3_3_Phase-FullFeatureTable.csv`)
  - Region-of-interest boundaries already demarked (`data/05062019_B3_3_Phase.zip`) 

```{r example}
library(CellPhe)
trial_name = "05062019_B3_3"
basedir <- "data"
```

The first step is to read in the raw images. Here tiff images in a folder 
called 05062019_B3_3_imagedata are expected.

```{r}
imagedata =  sprintf("%s/%s_imagedata", basedir, trial_name)
frames = readTiffs(imagedata)
```

Optionally, if there are already features available for each cell tracked 
they can be loaded in and copied. For example, the features requiring phase 
information can be copied in from the feature table output by PhaseFocus Livecyte 
software using the function copyPhaseFeatures(). Only the values for the features 
volume and sphericity, which require phase information, are copied as all other 
features can be calculated by the function extractFeatures(). Only cells that 
are tracked for a minimum of min_frames are copied into the new feature table. 
The output is a list of length N, where N is the number of cells tracked for at 
least the minimum number of frames specified (min_frames). The first element 
of the list contains the tracked cell identifiers (copied to 'original_IDs' below)
from the input file. The second element has, for each cell, a vector with length 
equal to the number of frames the cell is tracked for, with missing frames indicated 
by 1 and non-missing frames by 0 (copied to 'missing_frames' below). The third element 
of the output list contains the matrix of copied features for each frame of each 
tracked cell (copied to 'features' below).

![image](https://user-images.githubusercontent.com/12910047/178154414-3144549d-2c62-42cd-b624-828f7638f7eb.png)

```{r}
# COPY PHASE FEATURES FROM PHASEFOCUS FEATURE TABLE FOR EACH CELL TRACKED FOR MORE THAN MIN_FRAMES AND FIND MISSING FRAMES:
min_frames <- 50
input_feature_table =  sprintf("%s/%s_Phase-FullFeatureTable.csv", basedir, trial_name)
feature_table = copyPhaseFeatures(input_feature_table, 200)
original_IDs = feature_table[[1]]
missing_frames = feature_table[[2]]
features = feature_table[[3]]
```

Alternatively, pre-calculated features from any other tracking software can be read in
using the function copyFeatures() if the data is formatted in a csv file with tracked cell 
identifiers in the first column and the frame numbers in the second column, followed by a 
column for each features to be read in. The file should have column labels to be used in 
variable names. 

If no pre-existing features are available files providing tracked cell identifiers and information 
on missing frames ('original_IDs' and 'missing_frames') will need to be generated by the user.

![image](https://user-images.githubusercontent.com/12910047/178154884-d06f07b0-95f5-4900-b276-bbe6df2e462c.png)

In addition to any pre-calculated featutures, the extractFeatures() function reads in information on cell 
boundaries, the cell identifiers from the original tracking ('original_IDs') and information on missing 
frames for each cell ('missing_frames') together with the images for every frame ('frames'). 
The images and boundary information are used to calculate a total of 1109 descriptive features for each cell 
on every frame based on size, shape, texture and movement including the local cell density which are output 
together with a measure describing the trajectory of the cell over all frames. The output is a list with the 
trajectory variable for every cell tracked for at least min_frames in a list as the first element and the 
matrix of calculated feature time series in columns for these cells in a list as the second element.

![image](https://user-images.githubusercontent.com/12910047/178156942-282c37cc-5329-4cbe-9ec1-ecd4b9b8f698.png)

TODO ROI files - what other format could we deal with?
roi_file requires the following for every (non-missing) frame for each tracked cell:
roi$coords : a matrix of integers giving x and y pixel positions
roi$xrange : minimum and maximum pixel positions along x
roi$yrange : minimum and maximum pixel positions along y
roi$cellId : the cell identifier

![image](https://user-images.githubusercontent.com/12910047/178157097-d5d163e8-15c3-4f44-936f-89a84ee79b11.png)

```{r}
roi_files =  sprintf("%s/%s_Phase", basedir, trial_name)
new_features = extractFeatures(roi_files, original_IDs, missing_frames, frames, min_frames, framerate=0.0028)
```

Variables are calculated from the time series for any pre-existing features as well as the output of extractFeatures(), providing both summary statistics and indicators of time-series behaviour at different levels of detail obtained via wavelet analysis. 

![image](https://user-images.githubusercontent.com/12910047/178157253-92438bba-5778-4028-a227-5dc88b37a086.png)

```{r}
tsvariables = varsFromTimeSeries(features, new_features, original_IDs)
```

TODO classification/clustering
